\documentclass[a4paper]{article}

\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{latexsym}
\usepackage{amssymb,amsmath,amsthm}
\usepackage{cancel}
\usepackage[table]{xcolor}
\usepackage{listings}
\usepackage{mdwlist}
%\usepackage{pdflscape}
%\usepackage{rotating}
%\usepackage{mathrsfs}
%\usepackage{natbib}
%\usepackage{verbatim}
\usepackage{algorithm}
\usepackage{algpseudocode}



%\usepackage{tikz}
%\usetikzlibrary{shapes,arrows,backgrounds,fit}

\usepackage{url}
% should be the last package
\usepackage{hyperref}
% fix jumping to capture instead of figure
\usepackage[all]{hypcap}


\graphicspath{{./figures/}}


\bibliographystyle{plain}

\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{defin}[thm]{Definition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{cla}[thm]{Claim}



\lstset{ %
  language=Matlab,                % the language of the code
  basicstyle=\tt\scriptsize,         % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  xleftmargin=1cm,
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
%  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
%  showspaces=false,               % show spaces adding particular underscores
%  showstringspaces=false,         % underline spaces within strings
%  showtabs=false,                 % show tabs within strings adding particular underscores
%  frame=single,                   % adds a frame around the code
%  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
%  tabsize=2,                      % sets default tabsize to 2 spaces
%  captionpos=b,                   % sets the caption-position to bottom
%  breaklines=true,                % sets automatic line breaking
%  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
%  title=\lstname,                   % show the filename of files included with \lstinputlisting;
%                                  % also try caption instead of title
%  keywordstyle=\color{blue},          % keyword style
%  commentstyle=\color{dkgreen},       % comment style
%  stringstyle=\color{mauve},         % string literal style
%  escapeinside={\%*}{*)},            % if you want to add a comment within your code
%  morekeywords={*,...}               % if you want to add more keywords to the set
}


\newcommand{\dm}{\text{dm}^3}
\newcommand{\OtravelTo}{\text{O\_travelTo}}
\newcommand{\OtravelFrom}{\text{O\_travelFrom}}
\newcommand{\VVolume}{\text{V\_Volume}}

\author{Stefan Hepp, e0026640}

\title{Modeling and Solving Constrained Optimization Problems VU\\
  {\normalsize RMC Exercise}}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}

This report describes the modeling and implementation of the Ready-Mixed Concrete (RMC) problem exercise using Gecode.

\section{Instance Specification and Preprocessing}

The problem instances are described using XML files. They contain lists of orders, vehicles and stations. The output
nodes in the XML files are ignored.

The provided data files contain many entries that are invalid, as well as problems that are not satisfiable. Vehicles
that have neither a normal volume nor a maximum volume set are ignored, as well as stations without names. For each
order at least one vehicle must exist which can fulfill this order, otherwise the problem does not have a solution. 

In order to limit the model to integer variables, volumes of concrete are converted into integer units of $\dm$. Time
spans such as the time to load vehicles are represented in minutes, while points in time such as the start time of an
order are represented in minutes since the earliest time stamp in the problem specification. 
Discharge rates of the vehicles are expressed as integer values in $\dm$ per minutes.

While multiple orders for the same construction yard may exist but since travel
times are specified per order, not per yard, the problem was slightly simplified by assuming every order is for a
different construction yard, making construction yards and orders equivalent.
In the following, we thus only consider orders. If multiple orders for the same construction yard may exist, the 
constraint that allows only one vehicle to be unloaded per order must be modified to allow only one vehicle to be
unloaded per yard, by using the yard identifier instead of the order identifier to check for overlaps.

The travel times between stations and orders are converted from a variable length list per order to a single dense
matrix $\OtravelTo$ containing the 
travel times from stations to orders and to a matrix $\OtravelFrom$ containing the travel times from orders to yards.
If no value for a pair of order and station is given in the problem specification, it is assumed that it is not possible
to travel that route and the corresponding entries in the matrices are set to a very large value to avoid solutions that
contain such a route.

The amount of concrete that a vehicle can deliver may depend on the order. The volumes of all vehicles are precalculated
and stored in a matrix $\VVolume$ indexed by order and vehicle.

\medskip
In addition to the provided data files, a small example with just two orders, three vehicles and three stations was
created to test and experiment with the model.

\section{Representation of Deliveries}

The expected output of the RMC problem is a schedule for all vehicles which order has to be fulfilled from which
station at which point in time. There are at least three ways to represent this schedule. 

\begin{itemize}
\item A single list of deliveries
 might contain a vehicle index, a station index and an order index per delivery.

\item A list of deliveries for each order defines which vehicles serve this order.

\item A list of deliveries for each vehicle defines which orders are served by this vehicle.
\end{itemize}

The issue with all three representations is that the number of deliveries is not fixed, and it is not possible to have
the size of the delivery lists depend on decision variables.\footnote{It might be possible to store deliveries using
sets, but this has not been explored for this model.}
Instead, an upper bound on the number of deliveries is calculated, and an array of boolean variables defines per
delivery if it is used or not.

Since the first option uses only one single list, a tighter bound on the length of the list and thus on the number of
variables might be found. However, the other ways of modeling the problem simplify some ordering constraints, therefore
the first option was not further explored.

For this exercise a lists of deliveries for each vehicle were used. The advantage over lists per order is that it is
simpler to determine the travel times between stations and yards per vehicle, as the next trip of a vehicle can
be easily determined. The disadvantage is that the lag time between deliveries for a given order is much more difficult
to determine, but it was assumed that this is slightly less of an issue than determining the travel times for vehicles.


\section{Modeling and Constaints}

For each vehicle a list of deliveries containing different values per delivery exists. Those delivery lists have been implemented
as one matrix over vehicles and deliveries per value to represent, linearized into IntVarArrays.

\newcommand{\DOrder}{\text{D\_Order}}
\newcommand{\DStation}{\text{D\_Station}}
\newcommand{\DtLoad}{\text{D\_tLoad}}
\newcommand{\SdtLoad}{\text{S\_dTLoad}}
\newcommand{\DtUnload}{\text{D\_tUnload}}
\newcommand{\maxD}{\text{maxD}}
\newcommand{\VDeliveries}{\text{V\_Deliveries}}
\newcommand{\ODeliveries}{\text{O\_Deliveries}}
\newcommand{\DUsed}{\text{D\_Used}}
\newcommand{\DdTtravelTo}{\text{D\_dTTravelTo}}
\newcommand{\DdTtravelFrom}{\text{D\_dTTravelFrom}}
\newcommand{\DtArrival}{\text{D\_tArrival}}
\newcommand{\DDelivered}{\text{D\_Delivered}}
\newcommand{\DdTUnloading}{\text{D\_dTUnloading}}
\newcommand{\DPoured}{\text{D\_Poured}}
\newcommand{\OPoured}{\text{O\_Poured}}
\newcommand{\OReqDischargeRate}{\text{O\_ReqDischargeRate}}
\newcommand{\Tmax}{T_\text{max}}
\newcommand{\OstartTime}{\text{O\_startTime}}


\begin{itemize}
\item $\DOrder_{vd}$: The order vehicle $v$ is serving with delivery $d$.
\item $\DStation_{vd}$: The station vehicle $v$ is loaded at for delivery $d$.
\item $\DtLoad_{vd}$: The time when loading vehicle $v$ for delivery $d$ starts.
\item $\DtUnload_{vd}$: The time when unloading vehicle $v$ for delivery $d$ starts.
\end{itemize}

The size of each such matrix is $|V| \times |O| \cdot \maxD$, where $V$ is the list of available vehicles, $O$ the list of
orders, and $\maxD$ is an upper bound of deliveries per order per vehicle, and is currently derived as the number of
deliveries the smallest vehicle needs to fullfil the largest order on its own.

The number of deliveries per vehicle is stored as an array $\VDeliveries$ of size $|V|$. A boolean array $\DUsed$
defines for each delivery $vd$ if it contains valid values. To break symmetries, always the first $\VDeliveries_v$
deliveries are used, i.e.,
\[
  \DUsed_{vd} = (d < \VDeliveries_v)
\]

All unused deliveries are set to a fixed value:
\[
\begin{array}[b]{l}
  \DUsed_{vd} \vee \DOrder_{vd} = 0  \\
  \DUsed_{vd} \vee \DStation_{vd} = 0 \\
  \DUsed_{vd} \vee \DtLoad_{vd} = 0 \\
  \DUsed_{vd} \vee \DtUnload_{vd} = 0
\end{array}
\]

\medskip

Based on those structures we can now define various helper variables that will allow us to define constraints and the
cost function.

The travel time from a station to a yard $\DdTtravelTo$ for delivery $vd$ is defined as
\[
\begin{array}[b]{l}
(\DdTtravelTo_{vd} = \OtravelTo[\DOrder_{vd}, \DStation_{vd}] \wedge \DUsed_{vd}) \vee \\
(\DdTtravelTo_{vd} = 0 \wedge \neg \DUsed_{vd})
\end{array}
\]

The travel time from the yard back to the next station $\DdTtravelFrom$ of a delivery is defined to be 0 for the last
delivery $d = |O| \cdot \maxD - 1$ and for all other deliveries as
\[
\begin{array}[b]{l}
(\DdTtravelFrom_{v,d} = \OtravelFrom[\DOrder_{v,d+1}, \DStation_{v,d}] \wedge \DUsed_{v,d+1}) \vee \\
(\DdTtravelFrom_{v,d} = 0 \wedge \neg \DUsed_{v,d+1})
\end{array}
\]

The arrival time $\DtArrival$ of vehicle $v$ at the yard for delivery $d$ depends on the travel time of the vehicle plus
the time $\SdtLoad_s$ to load a vehicle at station $s$
\[
\begin{array}[b]{l}
(\DtArrival_{vd} = \DtLoad_{vd} + \SdtLoad[\DStation_{vd}] + \DdTtravelTo_{vd} \wedge \DUsed_{vd}) \vee \\
(\DtArrival_{vd} = 0 \wedge \neg \DUsed_{vd})
\end{array}
\]

The amount of concrete delivered $\DDelivered$ by a vehicle at a construction site depends on the order
\[
\begin{array}[b]{l}
(\DDelivered_{vd} = \VVolume[\DOrder_{vd}] \wedge \DUsed_{vd}) \vee \\
(\DDelivered_{vd} = 0 \wedge \neg \DUsed_{vd})
\end{array}
\]

For the time $\DdTUnloading$ required to unload a vehicle we simplify the problem by assuming that a vehicle is
completely unloaded at the discharge rate $\OReqDischargeRate$ defined by the order, even if the concrete goes bad.
\[
\DdTUnloading_{vd} = \frac{\DDelivered_{vd}}{ \OReqDischargeRate[ \DOrder_{vd} ]}
\]

Finally, the amount of concrete $\DPoured$ poured by a vehicle $v$ for a delivery $d$ however depends on the loading time. The amount of concrete delivered
is reduced if the time it takes to deliver the concrete exceeds $\Tmax$ = 100 minutes
\[
\DPoured_{vd} = \min( \DDelivered_{vd}, (\Tmax - \DtUnload_{vd} + \DtLoad_{vd]}) \cdot \OReqDischargeRate[\DOrder_{vd}] ) 
\]

\newcommand{\ODVolume}{\text{OD\_Volume}}

In order to calculate the amount poured per order $\OPoured$ for an order $o$, we sum up all volumes delivered for order $o$ in a
temporary array $\ODVolume_o$
\[
\begin{array}[b]{l}
(\ODVolume_{o,vd} = \DPoured_{vd} \wedge \DOrder_{vd} = o) \vee \\
(\ODVolume_{o,vd} = 0 \wedge \DOrder_{vd} \not = o)
\end{array}
\]

\[
\OPoured_o = \sum{\ODVolume_o} 
\]

Finally, we calculate the number of deliveries $\ODeliveries$ per order $o$. For this, the count constraint can be used, but
order 0 has to be handled specially, as this includes all unused orders. 
\[
\ODeliveries_o = \left\{
\begin{array}{l l}
\text{count}(\DOrder, o) - (|V| \cdot |O| \cdot \maxD - \sum{\DUsed}) & \quad \text{if $o = 0$} \\
\text{count}(\DOrder, o) & \quad \text{else}
\end{array}
\right.
\]

\section{Constraints}

All vehicles $v$ are defined to start all from the first station.
\[
\DStation_{v,0} = 0
\]

Vehicles are only available from a predefined time $\text{V\_availableFrom}_v$ for loading, and must not start unloading for an order before the 
order start time $\OstartTime_o$.
\[
\DtLoad_{v,0} \geq \text{V\_availableFrom}_v \vee \neg \DUsed_{v,0}
\]
\[
\DtUnload_{v,d} \geq \OstartTime[ \DUsed_{v,d} ] \vee \neg \DUsed_{v,d}
\]

All vehicles $v$ must match the requirements of the orders for the length of the pipeline $\text{O\_reqPipeLength}$ and the discharge rate $\text{O\_reqDischargeRate}$.
\[
\text{O\_reqPipeLength}[ \DOrder_{vd} ] \leq \text{V\_pipeLength}_v \vee \neg \DUsed_{vd} 
\]
\[
\text{O\_reqDischargeRate}[ \DOrder_{vd} ] \leq \text{V\_dischargeRate}_v \vee \neg \DUsed_{vd} 
\]

In order to ensure that deliveries for a vehicle do not overlap in time and to break symmetries for deliveries, the following constraint ensures
that deliveries per vehicle are sorted by time and that loading a vehicle only starts after it arrived at a station.
\[
\DtUnload_{v,d-1} + \DdTUnloading_{v,d-1} + \DdTtravelFrom_{v,d-1} \leq \DtLoad_{v,d} \vee \neg \DUsed_{vd}
\]

Similarly, unloading a vehicle can only start after the vehicle arrived at the construction yard and the vehicle has been set up for unloading, which takes $\text{O\_dTSetup}_o$ for order $o$.
\[
\DtArrival_{v,d} \leq \DtUnload_{v,d} - \text{O\_dTSetup}[ \DOrder_{v,d} ] \vee \neg \DUsed_{vd}
\]

In order to avoid unloading multiple vehicles at the same time, the unary constraint can be used. However, since vehicles can be 
unloaded at the same time at different construction yards, we use a boolean array $\text{AtYard}_o$ per construction yard $o$ to define to which deliveries
the unary constraint applies to. For the unary constraint, we also need the finish time of all deliveries $\text{D\_tUnloaded}$
\[
\text{AtYard}_{o,v,d} = (\DOrder_{v,d} = o) \vee \neg \DUsed_{v,d}
\]
\[
\text{D\_tUnloaded}_{v,d} = \DtUnload_{v,d} + \DdTUnloading_{v,d}
\]
\[
\text{unary}(\DtUnload, \DdTUnloading, \text{D\_tUnloading}, \text{AtYard}_o)
\]

Similarly, the unary constraint can be used to prevent overlaps of loading the vehicles at stations, using a $\text{AtStation}$ boolean array to encode
which deliveries are loaded at a station $s$. The loading time $\text{S\_tLoad}_s$ is a constant for each station $s$.
\[
\text{AtStation}_{s,v,d} = (\DStation_{v,d} = s) \vee \neg \DUsed_{v,d}
\]
\[
\text{unary}(\DtLoad, \text{S\_tLoad}_s, \text{AtStation}_s)
\]

\newcommand{\OtotalVolume}{\text{O\_totalVolume}}

Finally, all orders must be fulfilled, i.e., the requested amount of concrete $\OtotalVolume_o$ must be delivered for each order $o$
\[
\OPoured_o \geq \OtotalVolume_o
\]


\section{Modeling the Cost}

\newcommand{\ODMap}{\text{ODMap}}
\newcommand{\OWaste}{\text{O\_Waste}}
\newcommand{\OPreferred}{\text{O\_Preferred}}
\newcommand{\OLag}{\text{O\_Lag}}
\newcommand{\OLateness}{\text{O\_Lateness}}
\newcommand{\OtUnload}{\text{O\_tUnload}}

In order to calculate the cost of a solution, the waste $\OWaste_o$ for each order $o$, as well as the number of 
deliveries not delivered from the preferred station $\OPreferred_o$ have to be defined
\[
\OWaste_o = \OPoured_o - \OtotalVolume
\]
\[
\OPreferred_{vd} = (\DStation_{vd} \not = \text{O\_preferredStation}[ \DOrder_{vd} ] \wedge \DUsed_{vd}
\]

The total travel time of all vehicles is simply the sum over $\DdTtravelTo$ and $\DdTtravelFrom$. However, calculating the lateness and the lags of an
order is more complex. For this, we create a permutation $\ODMap$ of the deliveries so that they are indexed by orders instead of by vehicles.
The map is used to create a matrix $\OtUnload$ of size $|O| \times |V| \cdot \maxD$, which contains all unload times ordered by time for each order.

First, we enforce that deliveries per order are mapped to the appropriate indices of the orders per vehicle, and that the map describes a proper 
permutation, i.e., all indices are different. The domain of $\ODMap$ has been set to the interval $[0,\dots,|\ODMap|)$ to enforce that the map only contains
valid indices into the flat delivery lists.
\[
\begin{array}{l}
(\DOrder[\ODMap_{o,d}] = o \wedge d < \ODeliveries_o) || \\
(\DOrder[\ODMap_{o,d}] = 0 \wedge d \geq \ODeliveries_o) 
\end{array}
\]
\[
\text{distinct}(\ODMap)
\]

Using this map, the matrix $\OtUnload$ is set up to contain the unloading start times of all deliveries and enforced to be sorted by time.
\[
\OtUnload_{o,d} = \DtUnload[\ODMap_{o,d}]
\]
\[
\OtUnload_{o,d-1} < \OtUnload_{o,d} \vee d \geq \ODeliveries_o
\]

Based on the sorted unload times per order $o$, the lateness $\OLateness$ of an order is defined as
\[
\OLateness_o = \OtUnload_{o,0} - \OstartTime_o
\]
The lag $\OLag_{o,d}$ of a delivery $d$ for an order $o$ is the time difference between the unloading start times of successive deliveries for an order, 
minus the time it takes to unload the previous delivery.
\[
\begin{array}{l}
(\OLag_{o,d} = \OtUnload_{o,d} - \OtUnload_{o,d-1} - \DdTUnloading[ \ODMap_{o,d} ] \wedge d < \ODeliveries_o) \vee \\
(\OLag_{o,d} = 0 \wedge d \geq \ODeliveries_o)
\end{array}
\]
For the first delivery of each order, the lag is set to zero.
\[
\OLag_{o,0} = 0
\]

The total cost of a solution can now be modeled as
\[
\begin{array}{l l}
\text{Cost} = & \alpha_1 \cdot \sum \OLateness + \alpha_2 \cdot \sum \OWaste + \alpha_3 \cdot \sum \OPreferred + \alpha_4 \cdot \sum \OLag + \\
              & \alpha_5 \cdot (\sum \DdTtravelTo + \sum \DdTtravelFrom)
\end{array}
\]


\section{Evaluation and Improving the Model}

Gist was used to inspect the branching and the values determined by the solver. The ability to print out partial
solutions and to visualize the branch tree helped debugging the model a lot (e.g., in case Gecode fails when the cost
variable has not being assigned a single value due to insufficient constaints) and to gain insights into the performance of
the branchers.

\newcommand{\maxOD}{\text{maxOD}}

The first issue detected was that $\ODMap$ was not sufficiently restricted for unused delivery entries. In order to break symmetries, the following constraint
was added to enforce an order on the mapping of unused delivery entries per order, and to enforce an order on the
indices of unused deliveries between subsequent orders, where $\maxOD = |V| \cdot \maxD$, i.e., the maximum number
of deliveries per order.
\[
\ODMap_{o,d-1} < \ODMap_{o,d} \vee d-1 < \ODeliveries_o
\]
\[
\begin{array}{l}
\ODMap_{o-1,\maxOD - 1} < \ODMap[o, \ODeliveries_o] \, \vee \\
\ODeliveries_{o-1} = \maxOD - 1 \, \vee \\
\ODeliveries_o = \maxOD
\end{array}
\]




\section{Evaluation of the Model}


In hindsight, a model using unsorted sets for deliveries or a single list of deliveries (sorted by some value encoding
both time stamps and orders for symmetry breaking) that entails more complex constraints but fewer variables might have
been a better choice.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\clearpage
%\nocite{*}
%\bibliography{references}


\end{document}

